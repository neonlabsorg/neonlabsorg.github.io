"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5232],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(t),m=a,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return t?r.createElement(f,s(s({ref:n},d),{},{components:t})):r.createElement(f,s({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=u;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4722:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var r=t(7462),a=t(3366),o=(t(7294),t(3905)),s=["components"],i={},c="ERC20 SPL-Wrapper",l={unversionedId:"devportal/erc20wrapper",id:"devportal/erc20wrapper",isDocsHomePage:!1,title:"ERC20 SPL-Wrapper",description:"ERC20 SPL-Wrapper contract provides an access to native Solana tokens, registered in the SPL-token contract, through the ERC20 interface.",source:"@site/docs/devportal/erc20wrapper.md",sourceDirName:"devportal",slug:"/devportal/erc20wrapper",permalink:"/docs/devportal/erc20wrapper",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Neon EVM Architecture Overview",permalink:"/docs/devportal/neon_evm_arch"},next:{title:"Transaction Value token as an analogue of ETH for Neon EVM Solutions",permalink:"/docs/devportal/value_token"}},d=[{value:"Contract interface",id:"contract-interface",children:[]},{value:"Restrictions",id:"restrictions",children:[]},{value:"Finding the Token Account address",id:"finding-the-token-account-address",children:[]},{value:"Creating the Token Account",id:"creating-the-token-account",children:[]}],p={toc:d};function u(e){var n=e.components,t=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"erc20-spl-wrapper"},"ERC20 SPL-Wrapper"),(0,o.kt)("p",null,"ERC20 SPL-Wrapper contract provides an access to native Solana tokens, registered in the SPL-token contract, through the ERC20 interface."),(0,o.kt)("p",null,"This allows interaction of the Solana applications with EVM(Solidity/Vyper/etc.) bytecode contracts. ERC20 SPL-Wrapper can be also used to transfer funds in Solana tokens using Ethereum wallets such as Metamask."),(0,o.kt)("p",null,"Contract is implemented in Rust as part of NeonEVM program."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/neonlabsorg/neon-evm/blob/c43345d7abf7af14aa840e6b15c0fc64b084bb2c/evm_loader/program/src/precompile_contracts.rs#L106"},"Rust source code")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/neonlabsorg/neon-evm/blob/develop/evm_loader/SPL_ERC20_Wrapper.sol"},"Solidity wrapper source code")),(0,o.kt)("h3",{id:"contract-interface"},"Contract interface"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IERC20 {\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n    function approveSolana(bytes32 spender, uint64 value) external returns (bool);\n    event ApprovalSolana(address indexed owner, bytes32 indexed spender, uint64 value);\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"decimals()")," \u2014 Returns the number of decimals used to get its user representation. For example, if ",(0,o.kt)("inlineCode",{parentName:"p"},"decimals")," equals 2, a balance of 505 tokens should be displayed to a user as 5,05 (505 / 10 * 2)."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"totalSupply()")," \u2014 Returns the amount of tokens in existence."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"balanceOf(address account)")," \u2014 Returns the amount of tokens owned by ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"allowance(address owner, address spender)")," \u2014 Returns the remaining number of tokens that ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," will be allowed to spend on behalf of ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"\u200b\u200b\u200b\u200b\u200b\u200b\u200btransferFrom"),"\u200b\u200b\u200b\u200b\u200b\u200b\u200b. This is zero by default."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"transfer(address recipient, uint256 amount)")," \u2014 Sends specified amount of tokens  ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," from the caller's account balance to the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient")," account balance."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"approve(address spender, uint256 amount)")," \u2014 Sets ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," as the allowance of ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," over the caller's tokens."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"transferFrom(address sender, address recipient, uint256 amount)")," \u2014 Transfer ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"approveSolana(bytes32 spender, uint64 value)")," - Allows ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Solana"))," user ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," to withdraw from the caller's account multiple times, up to the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," amount. Only one Solana ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," can exists at the time. Translates into spl-token ",(0,o.kt)("inlineCode",{parentName:"p"},"Approve")," instruction."),(0,o.kt)("h3",{id:"restrictions"},"Restrictions"),(0,o.kt)("p",null,"According to spl-token structure, ",(0,o.kt)("em",{parentName:"p"},"u64")," is used to store the balance (in ERC20 it's ",(0,o.kt)("em",{parentName:"p"},"U256"),"). Based on ",(0,o.kt)("em",{parentName:"p"},"u64"),", maximum balance and transfer amounts are restricted by (2^64-1)/(10^9) (for 9 decimals accuracy)."),(0,o.kt)("h3",{id:"finding-the-token-account-address"},"Finding the Token Account address"),(0,o.kt)("p",null,"Token account for a given wallet address is a program-derived account consisting of two constants, the Ethereum wallet address itself, ERC20 contract address, and the token mint."),(0,o.kt)("p",null,"The account address can be derived in Rust with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'const ACCOUNT_SEED_VERSION: u8 = 1;\n\nfn token_address(owner: &H160, contract: &H160, mint: &Pubkey, neon_evm: &Pubkey) {\n    let seeds: &[&[u8]] = &[&[ACCOUNT_SEED_VERSION], b"ERC20Balance", &mint.to_bytes(), contract.as_bytes(), owner.as_bytes()];\n    Pubkey::find_program_address(seeds, neon_evm)\n}\n')),(0,o.kt)("h3",{id:"creating-the-token-account"},"Creating the Token Account"),(0,o.kt)("p",null,"Accounts hold token balances and are created using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ERC20CreateTokenAccount")," instruction."),(0,o.kt)("p",null,"This instruction can be created in Rust with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn create_token_account(funding: Pubkey, owner: H160, contract: H160, mint: Pubkey, neon_evm: Pubkey) {\n    let (token_address, _) = token_address(&owner, &contract, &mint, &neon_evm);\n    let (wallet_address, _) = Pubkey::find_program_address(&[&[ACCOUNT_SEED_VERSION], owner.as_bytes()], &neon_evm);\n    let (contract_address, _) = Pubkey::find_program_address(&[&[ACCOUNT_SEED_VERSION], contract.as_bytes()], &neon_evm);\n\n    Instruction::new_with_bincode(\n        neon_evm,\n        &(15_u8),\n        vec![\n            AccountMeta::new(funding, true),\n            AccountMeta::new(token_address, false),\n            AccountMeta::new_readonly(wallet_address, false),\n            AccountMeta::new_readonly(contract_address, false),\n            AccountMeta::new_readonly(mint, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n            AccountMeta::new_readonly(sysvar::rent::id(), false)\n        ]\n    )\n}\n")))}u.isMDXComponent=!0}}]);